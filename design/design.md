# Design File

## Changes to Application Design:
The biggest change that I made to the design of the *application* was in how music files would be handled. Out of inexperience, I had initially designed my concepts around the assumption that I could just store user-uploaded files in the database just as I did with any other piece of data. Unfortunately, I recently learned that I can't just do that, and the process for uploading and retriving files is more complicated than I thought. I ended up scrapping my old ResourceOwnership concept and creating a new FileUrl concept. It is almost similar to its predecessor in some aspects of its principle, but it differs a lot in its state and actions. The main thing is that it now uses the Google Cloud Storage service to upload, store, and retrieve files (this took A LOT of trial and error).


## Interesting Moments
1. I actually struggled with getting Context to only implement parts of a concept at first. I was using "implement:" instead of "prompt:". using the latter allowed me to incrementally implement my concepts using Context. In [this snapshot](../context/design/concepts/UserAuthentication/implementation.md/steps/response.9eb27d0e.md) was what I got from using "implement:" no matter what. I tried adding instructions after the "implement:" line but they seemed to have no effect. [This one](../context/design/concepts/UserAuthentication/implementation.md/steps/response.e9277c70.md) was what I got when I used prompt. I continued this strategy to incrementally develop all of my concepts

2. When first approaching tests, I came across a strange error. The only tests I had were for my User Authenticationʻs register action, but for some reason it would error like so:

![alt text](/media/error1.png)

I couldnʻt figure out what was wrong, so what I did was went back to the UserAuthentication testing.md file and asked it for help. I put in [this prompt](../context/design/concepts/UserAuthentication/testing.md/steps/prompt.175523c2.md) and [the current, failing test file](../context/design/concepts/UserAuthentication/testing.md/steps/file.d6057bde.md). I also outlines what the error was. The result was new test code which I ran and it ended up working without running into the same error as before!

3. I came to the realization when I was working on my second concept (MusicTagging) that when I am prompting Context for tests, I shouldnʻt only pass in a code implementation of the concept since it doesnʻt really "know" the operational principle of the concept on its own. To follow this idea, I started passing in the concept specification file. This ended up bringing about a bunch of other problems. [In this snapshot](../context/design/concepts/MusicTagging/testing.md/steps/response.6901b8c1.md), you can see how Context tried making its own register function. I had to change and test out the prompt over multiple iterations to end up with something that had the test suite actually written correctly. I believe that now Context knows that it should use the operational principle when designing tests.

4. Towards the end of my work on the MusicTagging concept, I realized that the assignment instructions say to only have 4-6 tests that test a detailed scenario. As you can see in these snapshots of my [UserAuthentication tests](../context/src/concepts/UserAuthentication/UserAuthenticationConcept.test.ts/20251011_141435.4f3cce5e.md) and [MusicTagging tests](../context/src/concepts/MusicTagging/MusicTaggingConcept.test.ts/20251011_210555.ed240fa2.md), they did not follow these instructions well. In order to remedy this, I used Context to generate a more proper test suite by also passing in the assignment instructions as a part of the prompt (see this [snapshot](../context/design/concepts/UserAuthentication/testing.md/steps/prompt.7fc64005.md) of my new UserAuthentication prompt as an example). Going forward from this point, I adopted a new way of querying Context for tests. As I iteratively implement actions, I will essentially tell the llm to add more to the "story" the the tests are testing using the newly implemented action. This allows for a concise and thorough test suite that can be built layer by layer (where the layers are actions as I implement them).

5. I tried basically everything I could think of to get Context to augment the tests to use the AI part of the MusicTagging correctly. No matter what I did, it seemed like Context just refused to simply initialize the Gemini LLM util to call the API. So many issues came up with its tests. For example, it tried making a "mock LLM" in nearly every single response, like [in this one](../context/design/concepts/MusicTagging/testing.md/steps/response.caf51824.md). It got to the point that I was worried that I was burning through my Gemini credits too fast, especially since the amount of tokens I put in and got out was immense. As a result, I ended up having to augment the tests that test the suggestTags method manually. I added tests for two situations: one where the model should suggest and add tags successfully, and one where the description is such that it shouldn't be able to give any tags (and error)

6. One of the big "interesting moments" for me was trying to figure out how to get file storage to work. I had absolutely no experience or knowledge of how to do it and I struggled to follow the help I got on Piazza. I went through a lot of things to get something that worked. One thing that I did was try to pass in a first draft of the FileUrl concept to Context to try and get it to design a more complete concept. I gave it [this](../context/design/concepts/FileUrl/generate-spec.md/steps/Concept.06b4719e.md) and it output [this](../context/design/concepts/FileUrl/generate-spec.md/steps/response.3e48fb32.md). As you can see, it wasn't very helpful on that front, and it output something that was definitely more complex than it needed to be. After this dead end, I resorted to a very "brute force" method. I basically had Context implement just the uploadFile action based on the spec and make tests based on it. Then, when I got errors, I would just feed whatever went wrong into Context and try to get out a new implementation (or tests). I repeated this process a ton. One of my iterations was like [this](../context/design/concepts/FileUrl/implementation.md/steps/response.ce311db3.md) and eventually I got to the point where my tests would error at the API calls, with errors like `Failed to upload file to Google Cloud Storage: Cannot insert legacy ACL for an object when uniform bucket-level access is enabled. Read more at https://cloud.google.com/storage/docs/uniform-bucket-level-access.`, which was great! This meant that the bulk of what was "wrong" had to do with things on my google cloud management side. I went onto the internet to research hooking up everything correctly, including making a bucket, service account, and a json that contains my google application credentials. After a few tweaks, I managed to get a functional file uploading action.

7. A point somewhat related to the last one is that I noticed that the Context tool gets really confused with using APIs with concepts. Typically, we want API calls, such as the Google Cloud Storage calls, to be contained within our concepts. I noticed during my implementation and testing of FileUrl that it really likes using the API in both implementation and testing, and it often makes "mock" objects to handle it. This is obviously very bad. An example of this is in [this test attempt](../context/design/concepts/FileUrl/testing.md/steps/file.cf963c1c.md), which showcases a particularly egregious attempt by Context to make up its own definitions for everything. In order to fix this type of issue, I added more instructions to both implementation and testing prompts that specified that API handling must be fully contained in the concepts. An example of a new testing prompt is [this one](../context/design/concepts/FileUrl/testing.md/steps/prompt.0403a18b.md) where I told it to assume that all API handling with FileUrl is done under the hood and all it has to worry about is passing in the file that it wants to upload. I also had to do prompt changes on the implementation side like [this](../context/design/concepts/FileUrl/implementation.md/steps/prompt.805b4927.md), where I specified that the implementation must be fully responsible for calling the Google Cloud Storage API and that it can't rely on any client to set up anything. These changes allowed the implementation/tests to be properly sectioned off so that they don't intrude into eachothers responsibilities.

8. An interesting thing that I encountered while testing FileUrl was that my tests would fail on consecutive runs because the buckets on the Google Cloud Console side weren't reset. A temporary solution that I had was manually going into the console after every test run to clean up the uploaded files myself. I realized that this was getting repetitive and came up with the idea to have the testing suite "reset" the bucket to its original state after it is done testing, making sure to remove any files that it added. I prompted it to do this with [this prompt](../context/design/concepts/FileUrl/testing.md/steps/prompt.191fce3c.md). Afterwards, it gave me a [test suite](context/design/concepts/FileUrl/testing.md/steps/response.54822259.md) that properly cleaned up the buckets for consecutive tests.

## Other Notes

Basically my approach for implementing went like ask Context to implement one action, make tests for that one action, check that everything works, if so then ask Context to add onto the current implementation (without changing anything) and test it and so forth. If an error comes up, Iʻll point to the current implementation/testing file and tell Context what was wrong with it.

In /design/concepts are folders containing all relevant files relating to the design of each concept. implementation.md is the file in which I prompted Context for a partial implementation of the concept. specification.md contains the concept spec for that folder. testing.md is the file in which I prompted Context for tests to the concept implementation. The design.md in each folder contains intformation about that concept's differences from the earlier assignments as well as any important information. Some folders have additional files, such as generate-spec.md. These files were just used to design concept specifications for the concepts where I wanted Context to help with my specifications.
