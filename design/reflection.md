2.5-flash-lite better than 2.5-flash for suggestTags


# Project Reflection

## What was hard?
For me a hard part was understanding how concepts should work together. It was hard for me to wrap my head around the notion that concepts should have no relation to the workings of other concepts, yet they must work together in syncs. This ended up in me designing incorrect concept specifications in earlier assignments that had a number of issues from poor modularity to bad seperation of concerns. A particular roadblock for me was understanding that the generic parameters we use in concept specs are IDs of the objects in the database. For a while I was confused and thought that these were whole objects whose attributes we could access.

## What was easy?
I definitely found it easy to do implementations and tests on the backend. It was such a similar thing to what we did in 6.102. From a specification, we would write tests and implement. I made sure to do this incrementally as well, and Context definitely made all this much easier. I would be able to implement and test one action at a time thanks to Context ªs ability to observe whole code files. I would just point it to the current test and implementation files and have it add the next action in order to build up test cases and implementations incrementally so that I could mandually go in and fix any issues that arise with ease.

## What went well?
As an overall reflection of my project, I think it went great. I was able to accomplish basically the same mission that I had from day one. My project seems to be a good solution to the initial problem I sought to face from the first few assignments. It allows for easy and clear sharing of musical feedback, and I am very proud of its progress. I am particularly proud of the UI/UX components, as that has been a weak side of mine in past projects. I feel that any user could log in and get some real use out of this app.

I also think that there are so many ways to add on to the app as well. Some improvements that I can just think of off the top of my head are: friending capabilities, allowing compositions to be seen by certain users, notifications for getting feedback, and suggesting compositions to users that fit their interests. I would have loved to add these functionalities, and I think that they (and more of them) would make the app better, but I didn't want to be too ambitious and half-complete them or break other core functionalities. Perhaps in the future I will return to this project and do these changes.

## What mistakes did you make, and how would you avoid making them in the future?
I made many mistakes in this project. A source of many problems was with my FileUrl concept. I had grossly misunderstood how file uploads work from the first day. My initial design even tried just saving the entire file to the database. I went though multiple iterations of the FileUrl concept and had to do a lot of research into how to make Google Cloud Storage work. It was a long process filled with many errors. I toiled using both Context and ChatGPT to figure out how to configure my GCS so that I could handle files. Even when I thought I had a working version that was able to intereact with GCS on the backend tests, I had to learn the hard way that a front end application can't just pass in file paths to the backend and expect it to be able to upload these.

I definitely could have avoided all these mistakes completely if I had gone to office hours to get help. I asked on Piazza for help, but there was only so much I could understand from the words on a screen. I didn't go to office hours typically because by the time I got to working on that week's assignment, there were no office hours between then and the deadline. In the future, I should definitely make sure to work on these types of projects as soon as I can (or at least look/plan it ahead of time) so that if any questions or issues come up, I can go to office hours and get help. If I had known that I needed help on certain parts, it would have made mistakes like those I made in FileUrl easier to fix or even non-existent.

## What skills did you acquire and which do you feel you still need to develop further?

I developed a couple of skills. I had never coded with the help of an LLM, and I believe that my experience with this project has helped me understand how to do so effectively, which is an important industry skill. I also learned a lot about designing "good code" in general. By this I mean designing concepts that follow all the signs of good coding practices. At first, this was difficult, but I believe that now I have a good intuition for designing concepts that achieve my goals while following the guidelines for good concepts.

A skill that I think I need more time with is in writing syncs. For this last project, I really struggled to understand why, how, when, etc. to design effective syncs. I'm not even sure if what I have now is what we are expected to do from our syncs. I kind of understand why we want this type of logic to be on the back end rather than front end, but for a lot of my syncs it seems like they are just wrappers around actions (with the session checking). I also struggled a lot with understanding the difference between excluded and included routes. I ended up just making all my query routes included and the rest excluded, but I'm still not sure on what should make a route included vs. excluded

## How did you use the Context tool?

I used the Context tool in basically everything related to the backend. For most of my concept specs, I wrote them on my own, but I sometimes would ask Context to change/add to them. From these specs, I had Context write code for all the implementations and tests for all the concepts. I also had Context write the API specs as well as the syncs when we got to those parts of the project. For each of these areas, I would point to relevant files and simply prompt Context to do what I want for that part. Of course, for all of these, I had to manually go in and check that what it gave me was actually correct.

## How did you use an agentic coding tool?

I primarily used the Copilot tool on the front end side. It was super useful. I used it to write nearly the whole front end. The only times I would manually do things is if it made errors in interacting with the backend or when I wanted to tweak small visual design aspects. I started by having Copilot create the initual Vue app. Then, I would sort of "step through" the user journey of my app and implement things one by one on the front end. For example, I started by having Copilot make a login/register page, then a home page, etc. When Vue implemented an iteration, I would mannually test on the localhost site (with my backend server running) to ensure that the added logic was working. Eventually, I got to an MVP. It was only when I had all the "logic" and functionality of my app working that I had Copilot work on visual aspects. I gave it a palette of colors that I liked and had it just try a whole bunch of things. I would tell it to do things like "make all boxes rounded" or "use more of this color" or "add an animation for this part" or even "make the app more warm and welcoming". As I did these prompts, I would check the effects they had. Sometimes, they would make something not work or would just not be what I wanted. If this happened, I would undo the effects of the last prompt and create a new prompt that hones in on my concerns. In the end, I am satisfied with the result.

## What conclusions would you draw about the appropriate role of LLMs in software development?

I think that there's just so much to say about this question and a lot of ways to answer it. However, in the interest of length, I will give something shorter. My main conclusion from this assignment is that LLMs can totally be used in software development to do "menial work" like writing CSS or repetitive code. However, I believe that they should only be used when the programmer has a solid design/specification for their app. Sure LLMs are good (and continuously getting better) at writing code. However, as mentioned in class, it seems that they struggle to design good code/apps that satisfy human needs/problems by themselves. Thus, it is up to us as software developers to do the designing that truly makes an app good. It doesn't matter if your app was coded in a single prompt to Copilot; If it isn't designed for humans, something we are best at, then humans won't use it.
